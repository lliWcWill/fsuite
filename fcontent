#!/usr/bin/env bash
# fcontent — search inside files using ripgrep (rg).
# Works on a directory tree OR on a list of file paths passed via stdin (agent-friendly).

set -euo pipefail

VERSION="1.1.0"

# -------------------------
# Telemetry — opt-out via FSUITE_TELEMETRY=0
# -------------------------
_FSUITE_TELEM="${FSUITE_TELEMETRY:-1}"
_TELEM_START_MS=$(date +%s%3N 2>/dev/null || echo 0)
_TELEM_EXIT_CODE=0

_fsuite_record_telemetry() {
  _TELEM_EXIT_CODE=$?
  [[ "$_FSUITE_TELEM" == "1" ]] || return 0
  [[ "$_TELEM_START_MS" != "0" ]] || return 0
  [[ "$_TELEM_START_MS" =~ ^[0-9]+$ ]] || return 0
  local end_ms
  end_ms=$(date +%s%3N 2>/dev/null || echo 0)
  [[ "$end_ms" != "0" ]] || return 0
  [[ "$end_ms" =~ ^[0-9]+$ ]] || return 0
  local dur_ms=$(( end_ms - _TELEM_START_MS ))
  local telem_dir="$HOME/.fsuite"
  mkdir -p "$telem_dir" 2>/dev/null || return 0
  local ts
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "unknown")
  local mode="directory"
  (( ${FILES_FROM_STDIN:-0} == 1 )) && mode="stdin_files"
  local ph=""
  if [[ -n "${SEARCH_PATH:-}" ]]; then
    local abs_sp
    abs_sp=$(cd "$SEARCH_PATH" 2>/dev/null && pwd) || abs_sp="$SEARCH_PATH"
    ph=$(printf "%s" "$abs_sp" | sha256sum 2>/dev/null | cut -c1-16) || ph="unknown"
  fi
  # Sanitize project name: alphanumeric + safe chars only
  local pn=""
  if [[ -n "${SEARCH_PATH:-}" ]]; then
    local abs_pn
    abs_pn=$(cd "$SEARCH_PATH" 2>/dev/null && pwd) || abs_pn="$SEARCH_PATH"
    pn=$(basename "$abs_pn" | tr -cd '[:alnum:]. _-')
  fi
  local _telem_line="{\"timestamp\":\"$ts\",\"tool\":\"fcontent\",\"version\":\"$VERSION\",\"mode\":\"$mode\",\"path_hash\":\"$ph\",\"project_name\":\"$pn\",\"duration_ms\":$dur_ms,\"exit_code\":$_TELEM_EXIT_CODE,\"depth\":-1,\"items_scanned\":${TOTAL_FILES:-0},\"bytes_scanned\":-1,\"flags\":\"-o ${OUTPUT:-pretty}\",\"backend\":\"rg\"}"
  # Atomic append with flock to prevent interleaved writes
  {
    flock -x 200 2>/dev/null
    echo "$_telem_line" >> "$telem_dir/telemetry.jsonl"
  } 200>"$telem_dir/.telemetry.lock" 2>/dev/null || true
}
trap '_fsuite_record_telemetry' EXIT

DEFAULT_PATH="."
DEFAULT_OUTPUT="pretty"     # pretty|paths|json
DEFAULT_MAX_MATCHES=200     # cap printed matches to avoid terminal floods
DEFAULT_MAX_FILES=2000      # cap file list read from stdin to avoid accidental explosions
                                # --rg-args accumulates into RG_ARGS array

die() { echo "Error: $*" >&2; exit 1; }
has() { command -v "$1" >/dev/null 2>&1; }

usage() {
  cat <<'EOF'
fcontent — search inside files (uses ripgrep "rg"), agent-friendly

USAGE
  fcontent [OPTIONS] <query> [path]

MODES
  1) Directory mode:
     fcontent "needle" /some/dir
     - Searches recursively under /some/dir

  2) Piped file-list mode (best with fsearch):
     fsearch --output paths '*.log' /var/log | fcontent "ERROR"
     - Reads file paths from stdin and searches only those files

OPTIONS
  -p, --path PATH
      Directory to search (recursive). Default: current directory.
      Ignored if paths are provided via stdin.

  -o, --output pretty|paths|json
      pretty: human-readable summary + sample matches (default)
      paths:  print unique file paths that matched (one per line)
      json:   print compact JSON with match metadata (best for AI agents)

  --max-matches N
      Limit number of printed matches in pretty/json output. Default: 200

  --max-files N
      When reading from stdin, limit number of file paths consumed (safety). Default: 2000

  --rg-args "..."
      Extra arguments passed to rg (advanced).
      Example: --rg-args "-i --hidden"

  --install-hints
      Print how to install rg and exit.

  --self-check
      Verify rg exists and show setup tips. Exit.

  -h, --help
      Show help and exit.

NOTES
  - This tool searches file CONTENTS, not filenames.
  - For filenames/paths, use fsearch.
  - Quote your query if it contains spaces:
      fcontent "fatal error" /path

HEADLESS / AI AGENT USAGE
  Best outputs for agents:
    fcontent --output json "token" /path
    fcontent --output paths "ERROR" < <(fsearch --output paths '*.log' /path)

SECURITY / SUDO
  This tool does not store credentials.
  If you need to read protected files, run with sudo:
    sudo fcontent "needle" /var/log
  If installing packages, authenticate once first:
    sudo -v

EOF
}

print_install_hints() {
  cat <<'EOF'
Install ripgrep (rg):

Debian/Ubuntu:
  sudo apt update && sudo apt install -y ripgrep

Tip: authenticate once first (helps if doing multiple installs):
  sudo -v
EOF
}

# Minimal JSON escape for strings
json_escape() {
  sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\t/\\t/g' -e 's/\r/\\r/g' -e ':a;N;$!ba;s/\n/\\n/g'
}

# -------------------------
# Parse args
# -------------------------
QUERY=""
SEARCH_PATH="$DEFAULT_PATH"
OUTPUT="$DEFAULT_OUTPUT"
MAX_MATCHES="$DEFAULT_MAX_MATCHES"
MAX_FILES="$DEFAULT_MAX_FILES"
RG_ARGS=()
INSTALL_HINTS=0
SELF_CHECK=0

POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--path) SEARCH_PATH="${2:-}"; shift 2 ;;
    -o|--output) OUTPUT="${2:-}"; shift 2 ;;
    --max-matches) MAX_MATCHES="${2:-}"; shift 2 ;;
    --max-files) MAX_FILES="${2:-}"; shift 2 ;;
    --rg-args)
      if [[ -n "${2:-}" ]]; then
        read -r -a _rg_tokens <<< "${2}"
        RG_ARGS+=("${_rg_tokens[@]}")
      fi
      shift 2 ;;
    --install-hints) INSTALL_HINTS=1; shift ;;
    --self-check) SELF_CHECK=1; shift ;;
    -h|--help) usage; exit 0 ;;
    --version) echo "fcontent $VERSION"; exit 0 ;;
    -*) die "Unknown option: $1 (try --help)" ;;
    *) POSITIONAL+=("$1"); shift ;;
  esac
done

QUERY="${POSITIONAL[0]:-}"
if [[ -n "${POSITIONAL[1]:-}" ]]; then
  SEARCH_PATH="${POSITIONAL[1]}"
fi

if (( INSTALL_HINTS == 1 )); then
  print_install_hints
  exit 0
fi

if (( SELF_CHECK == 1 )); then
  echo "Self-check:"
  if has rg; then
    echo "  ✓ rg available ($(command -v rg))"
  else
    echo "  ✗ rg not found. Run: fcontent --install-hints"
  fi
  echo ""
  echo "If installing packages and you want fewer sudo prompts:"
  echo "  sudo -v"
  exit 0
fi

[[ -n "$QUERY" ]] || die "Missing query. Try: fcontent --help"
case "$OUTPUT" in pretty|paths|json) ;; *) die "Invalid --output: $OUTPUT" ;; esac
[[ "$MAX_MATCHES" =~ ^[0-9]+$ ]] || die "--max-matches must be an integer"
[[ "$MAX_FILES" =~ ^[0-9]+$ ]] || die "--max-files must be an integer"

has rg || die "rg (ripgrep) is required. Run: fcontent --install-hints"

# -------------------------
# Determine input: stdin file list vs directory mode
# -------------------------
# If the user explicitly gave a path (positional or --path that isn't the
# default "."), always use directory mode.  Only treat a non-terminal stdin
# as a piped file list when no explicit path was provided.
EXPLICIT_PATH=0
if [[ -n "${POSITIONAL[1]:-}" ]] || [[ "$SEARCH_PATH" != "$DEFAULT_PATH" ]]; then
  EXPLICIT_PATH=1
fi

FILES_FROM_STDIN=0
if (( EXPLICIT_PATH == 0 )) && ! [ -t 0 ]; then
  FILES_FROM_STDIN=1
fi

# Build file list if using stdin
TMP_LIST=""
cleanup() {
  [[ -n "$TMP_LIST" && -f "$TMP_LIST" ]] && rm -f "$TMP_LIST" || true
}
trap 'cleanup; _fsuite_record_telemetry' EXIT

if (( FILES_FROM_STDIN == 1 )); then
  TMP_LIST="$(mktemp)"
  # Read up to MAX_FILES lines, drop empties, keep as-is
  awk 'NF{print}' | head -n "$MAX_FILES" > "$TMP_LIST"

  if [[ ! -s "$TMP_LIST" ]]; then
    die "No file paths received on stdin."
  fi
fi

# -------------------------
# Run rg
# -------------------------
# We'll gather matches in a controlled way:
# - In pretty/json: collect up to MAX_MATCHES lines from rg output
# - In paths: output unique file paths

# Common rg flags:
# --no-messages: suppress permission noise
# --with-filename --line-number: useful metadata
BASE_RG=(rg --no-messages --with-filename --line-number)

# RG_ARGS is already an array (populated by --rg-args flags)

if [[ "$OUTPUT" == "paths" ]]; then
  if (( FILES_FROM_STDIN == 1 )); then
    xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" 2>/dev/null | sort -u || true
  else
    "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | sort -u || true
  fi
  exit 0
fi

# For pretty/json, we want match lines
# || true: rg returns 1 on no matches; head can cause SIGPIPE under pipefail
if (( FILES_FROM_STDIN == 1 )); then
  mapfile -t MATCH_LINES < <(xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -- "$QUERY" 2>/dev/null | head -n "$MAX_MATCHES" || true)
else
  mapfile -t MATCH_LINES < <("${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | head -n "$MAX_MATCHES" || true)
fi

# Extract unique matched filenames from MATCH_LINES (avoids redundant rg invocation).
# rg output format: filename:linenum:content
# Regex handles filenames containing colons (matches first colon followed by digits).
mapfile -t MATCH_FILES < <(
  for line in "${MATCH_LINES[@]+"${MATCH_LINES[@]}"}"; do
    if [[ "$line" =~ ^(.+):([0-9]+): ]]; then
      printf '%s\n' "${BASH_REMATCH[1]}"
    fi
  done | sort -u || true
)

SHOWN_MATCHES="${#MATCH_LINES[@]}"
TOTAL_FILES="${#MATCH_FILES[@]}"

# TOTAL_FILES defaults to MATCH_FILES (derived from MATCH_LINES).
# If we likely truncated matches, recompute TOTAL_FILES from the full rg pass.
# Keep SHOWN_MATCHES as the capped number from MATCH_LINES.
if (( SHOWN_MATCHES == MAX_MATCHES )); then
  if (( FILES_FROM_STDIN == 1 )); then
    mapfile -t FULL_MATCH_FILES < <(
      xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" 2>/dev/null | sort -u || true
    )
  else
    mapfile -t FULL_MATCH_FILES < <(
      "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | sort -u || true
    )
  fi
  TOTAL_FILES="${#FULL_MATCH_FILES[@]}"
fi

if [[ "$OUTPUT" == "json" ]]; then
  echo -n "{"
  echo -n "\"tool\":\"fcontent\","
  echo -n "\"version\":\"$VERSION\","
  echo -n "\"query\":\"$(printf "%s" "$QUERY" | json_escape)\","
  if (( FILES_FROM_STDIN == 1 )); then
    echo -n "\"mode\":\"stdin_files\","
  else
    echo -n "\"mode\":\"directory\","
    echo -n "\"path\":\"$(printf "%s" "$SEARCH_PATH" | json_escape)\","
  fi
  echo -n "\"total_matched_files\":$TOTAL_FILES,"
  echo -n "\"shown_matches\":$SHOWN_MATCHES,"
  echo -n "\"matches\":["
  for ((i=0; i<SHOWN_MATCHES; i++)); do
    line="$(printf "%s" "${MATCH_LINES[i]}" | json_escape)"
    if (( i > 0 )); then echo -n ","; fi
    echo -n "\"$line\""
  done
  echo -n "],"
  echo -n "\"matched_files\":["
  for ((i=0; i<TOTAL_FILES && i<200; i++)); do
    f="$(printf "%s" "${MATCH_FILES[i]}" | json_escape)"
    if (( i > 0 )); then echo -n ","; fi
    echo -n "\"$f\""
  done
  echo -n "]}"
  echo
  exit 0
fi

# pretty output
echo "ContentSearch(query: \"$QUERY\")"
if (( FILES_FROM_STDIN == 1 )); then
  echo "  ⎿ mode: stdin_files (max_files=$MAX_FILES)"
else
  echo "  ⎿ mode: directory path=\"$SEARCH_PATH\""
fi
echo "  ⎿ matched_files: $TOTAL_FILES"
echo "  ⎿ shown_matches: $SHOWN_MATCHES (cap=$MAX_MATCHES)"
if (( SHOWN_MATCHES == 0 )); then
  exit 0
fi
for line in "${MATCH_LINES[@]}"; do
  echo "     $line"
done
