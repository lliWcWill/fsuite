#!/usr/bin/env bash
# fcontent — search inside files using ripgrep (rg).
# Works on a directory tree OR on a list of file paths passed via stdin (agent-friendly).

set -euo pipefail

VERSION="1.6.1"

# -------------------------
# Source common library for tiered telemetry
# -------------------------
_FSUITE_SCRIPT_DIR="$(cd "$(dirname "$(realpath "$0" 2>/dev/null || readlink -f "$0" 2>/dev/null || echo "$0")")" && pwd)"
_FSUITE_LIB="$_FSUITE_SCRIPT_DIR/_fsuite_common.sh"
[[ ! -f "$_FSUITE_LIB" ]] && _FSUITE_LIB="/usr/share/fsuite/_fsuite_common.sh"
[[ -f "$_FSUITE_LIB" ]] && source "$_FSUITE_LIB" || true

# -------------------------
# Telemetry — opt-out via FSUITE_TELEMETRY=0
# Tiers: 0=disabled, 1=timing+bytes, 2=+hardware, 3=+profile
# -------------------------
_FSUITE_TELEM="${FSUITE_TELEMETRY:-1}"
[[ "$_FSUITE_TELEM" =~ ^[0-9]+$ ]] || _FSUITE_TELEM=1
_TELEM_START_MS=$(date +%s%3N 2>/dev/null || echo 0)
_TELEM_EXIT_CODE=0
_TELEM_BYTES=-1
_TELEM_FLAGS=""
_TELEM_PROJECT_NAME=""

_fsuite_record_telemetry() {
  _TELEM_EXIT_CODE=$?
  (( _FSUITE_TELEM >= 1 )) || return 0
  [[ "$_TELEM_START_MS" != "0" ]] || return 0
  [[ "$_TELEM_START_MS" =~ ^[0-9]+$ ]] || return 0
  local end_ms
  end_ms=$(date +%s%3N 2>/dev/null || echo 0)
  [[ "$end_ms" != "0" ]] || return 0
  [[ "$end_ms" =~ ^[0-9]+$ ]] || return 0
  local dur_ms=$(( end_ms - _TELEM_START_MS ))
  (( dur_ms < 0 )) && dur_ms=0
  local telem_dir="$HOME/.fsuite"
  mkdir -p "$telem_dir" 2>/dev/null || return 0
  local ts
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "unknown")
  local mode="directory"
  (( ${FILES_FROM_STDIN:-0} == 1 )) && mode="stdin_files"
  local ph=""
  if [[ -n "${SEARCH_PATH:-}" ]]; then
    local abs_sp
    abs_sp=$(cd "$SEARCH_PATH" 2>/dev/null && pwd) || abs_sp="$SEARCH_PATH"
    ph=$(printf "%s" "$abs_sp" | sha256sum 2>/dev/null | cut -c1-16) || true
    [[ -z "$ph" ]] && ph="unknown"
  fi
  # Sanitize project name: alphanumeric + safe chars only
  local pn=""
  if [[ -n "${SEARCH_PATH:-}" ]]; then
    local abs_pn
    abs_pn=$(cd "$SEARCH_PATH" 2>/dev/null && pwd) || abs_pn="$SEARCH_PATH"
    if type _fsuite_infer_project_name &>/dev/null; then
      pn=$(_fsuite_infer_project_name "$abs_pn")
    else
      pn=$(basename "$abs_pn" | tr -cd '[:alnum:]. _-')
    fi
  fi
  if [[ -n "${_TELEM_PROJECT_NAME:-}" ]]; then
    pn=$(printf '%s' "$_TELEM_PROJECT_NAME" | tr -cd '[:alnum:]. _-')
  fi
  # Compute bytes_scanned in directory mode only (not stdin mode)
  if [[ "$_TELEM_BYTES" -eq -1 ]] && (( ${FILES_FROM_STDIN:-0} == 0 )) && [[ -d "${SEARCH_PATH:-}" ]]; then
    local _bs=""
    if command -v timeout >/dev/null 2>&1; then
      _bs=$(timeout 3 du -sb "$SEARCH_PATH" 2>/dev/null | cut -f1) || _bs=""
    else
      # macOS fallback: no timeout, use du -sk * 1024
      _bs=$(du -sk "$SEARCH_PATH" 2>/dev/null | cut -f1) || _bs=""
      [[ "${_bs:-}" =~ ^[0-9]+$ ]] && _bs=$(( _bs * 1024 ))
    fi
    [[ "${_bs:-}" =~ ^[0-9]+$ ]] && _TELEM_BYTES="$_bs"
  fi
  # Collect hardware telemetry if tier >= 2
  if type _fsuite_collect_hw_telemetry &>/dev/null; then
    _fsuite_collect_hw_telemetry "$_FSUITE_TELEM" "${SEARCH_PATH:-}"
  fi
  local _hw_fields=""
  if type _fsuite_hw_json_fields &>/dev/null && (( _FSUITE_TELEM >= 2 )); then
    _hw_fields=$(_fsuite_hw_json_fields "$_FSUITE_TELEM")
    [[ -n "$_hw_fields" ]] && _hw_fields=",${_hw_fields}"
  fi
  local _safe_flags
  _safe_flags=$(printf '%s' "${_TELEM_FLAGS# }" | tr -cd '[:alnum:] _./-' | head -c 200)
  local _telem_line="{\"timestamp\":\"$ts\",\"tool\":\"fcontent\",\"version\":\"$VERSION\",\"mode\":\"$mode\",\"path_hash\":\"$ph\",\"project_name\":\"$pn\",\"duration_ms\":$dur_ms,\"exit_code\":$_TELEM_EXIT_CODE,\"depth\":-1,\"items_scanned\":${TOTAL_FILES:-0},\"bytes_scanned\":${_TELEM_BYTES},\"flags\":\"$_safe_flags\",\"backend\":\"rg\"${_hw_fields}}"
  # Atomic append with flock to prevent interleaved writes
  {
    flock -x 200 2>/dev/null
    echo "$_telem_line" >> "$telem_dir/telemetry.jsonl"
  } 200>"$telem_dir/.telemetry.lock" 2>/dev/null || true
}

DEFAULT_PATH="."
DEFAULT_OUTPUT="pretty"     # pretty|paths|json
DEFAULT_MAX_MATCHES=200     # cap printed matches to avoid terminal floods
DEFAULT_MAX_FILES=2000      # cap file list read from stdin to avoid accidental explosions
                                # --rg-args accumulates into RG_ARGS array

die() { echo "Error: $*" >&2; exit 1; }
has() { command -v "$1" >/dev/null 2>&1; }

usage() {
  cat <<'EOF'
fcontent — search inside files (uses ripgrep "rg"), agent-friendly

USAGE
  fcontent [OPTIONS] <query> [path]

MODES
  1) Directory mode:
     fcontent "needle" /some/dir
     - Searches recursively under /some/dir

  2) Piped file-list mode (best with fsearch):
     fsearch --output paths '*.log' /var/log | fcontent "ERROR"
     - Reads file paths from stdin and searches only those files

OPTIONS
  -p, --path PATH
      Directory to search (recursive). Default: current directory.
      Ignored if paths are provided via stdin.

  -o, --output pretty|paths|json
      pretty: human-readable summary + sample matches (default)
      paths:  print unique file paths that matched (one per line)
      json:   print compact JSON with match metadata (best for AI agents)

  -m, --max-matches N
      Limit number of printed matches in pretty/json output. Default: 200

  -n, --max-files N
      When reading from stdin, limit number of file paths consumed (safety). Default: 2000

  -q, --quiet
      Suppress header lines in pretty mode. Useful for scripting.

  --project-name <name>
      Override project name in telemetry.

  --rg-args "..."
      Extra arguments passed to rg (advanced).
      Example: --rg-args "-i --hidden"

  --install-hints
      Print how to install rg and exit.

  --self-check
      Verify rg exists and show setup tips. Exit.

  -h, --help
      Show help and exit.

NOTES
  - This tool searches file CONTENTS, not filenames.
  - For filenames/paths, use fsearch.
  - Quote your query if it contains spaces:
      fcontent "fatal error" /path

HEADLESS / AI AGENT USAGE
  Best outputs for agents:
    fcontent --output json "token" /path
    fcontent --output paths "ERROR" < <(fsearch --output paths '*.log' /path)

SECURITY / SUDO
  This tool does not store credentials.
  If you need to read protected files, run with sudo:
    sudo fcontent "needle" /var/log
  If installing packages, authenticate once first:
    sudo -v

EOF
}

print_install_hints() {
  cat <<'EOF'
Install ripgrep (rg):

Debian/Ubuntu:
  sudo apt update && sudo apt install -y ripgrep

Tip: authenticate once first (helps if doing multiple installs):
  sudo -v
EOF
}

# Minimal JSON escape for strings
json_escape() {
  sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\t/\\t/g' -e 's/\r/\\r/g' -e ':a;N;$!ba;s/\n/\\n/g'
}

# -------------------------
# Parse args
# -------------------------
QUERY=""
SEARCH_PATH="$DEFAULT_PATH"
OUTPUT="$DEFAULT_OUTPUT"
MAX_MATCHES="$DEFAULT_MAX_MATCHES"
MAX_FILES="$DEFAULT_MAX_FILES"
RG_ARGS=()
INSTALL_HINTS=0
SELF_CHECK=0
QUIET=0

# Pre-process arguments: expand combined short flags like -m5 to -m 5
_args=()
for _arg in "$@"; do
  if [[ "$_arg" =~ ^-([mn])([0-9]+)$ ]]; then
    _args+=("-${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
  else
    _args+=("$_arg")
  fi
done
set -- "${_args[@]}"

POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--path) SEARCH_PATH="${2:-}"; shift 2 ;;
    -o|--output) OUTPUT="${2:-}"; shift 2 ;;
    -m|--max-matches) MAX_MATCHES="${2:-}"; _TELEM_FLAGS+=" -m $2"; shift 2 ;;
    -n|--max-files) MAX_FILES="${2:-}"; _TELEM_FLAGS+=" -n $2"; shift 2 ;;
    -q|--quiet) QUIET=1; _TELEM_FLAGS+=" -q"; shift ;;
    --rg-args)
      if [[ -n "${2:-}" ]]; then
        read -r -a _rg_tokens <<< "${2}"
        RG_ARGS+=("${_rg_tokens[@]}")
      fi
      _TELEM_FLAGS+=" --rg-args"
      shift 2 ;;
    --project-name)
      [[ -n "${2:-}" ]] || die "Missing value for --project-name"
      _TELEM_PROJECT_NAME="$2"; shift 2 ;;
    --install-hints) INSTALL_HINTS=1; shift ;;
    --self-check) SELF_CHECK=1; shift ;;
    -h|--help) usage; exit 0 ;;
    --version) echo "fcontent $VERSION"; exit 0 ;;
    -*) die "Unknown option: $1 (try --help)" ;;
    *) POSITIONAL+=("$1"); shift ;;
  esac
done

QUERY="${POSITIONAL[0]:-}"
if [[ -n "${POSITIONAL[1]:-}" ]]; then
  SEARCH_PATH="${POSITIONAL[1]}"
fi

if (( INSTALL_HINTS == 1 )); then
  print_install_hints
  exit 0
fi

if (( SELF_CHECK == 1 )); then
  echo "Self-check:"
  if has rg; then
    echo "  ✓ rg available ($(command -v rg))"
  else
    echo "  ✗ rg not found. Run: fcontent --install-hints"
  fi
  echo ""
  echo "If installing packages and you want fewer sudo prompts:"
  echo "  sudo -v"
  exit 0
fi

# Seed telemetry flags with defaults
_TELEM_FLAGS+=" -o ${OUTPUT:-pretty}"

[[ -n "$QUERY" ]] || die "Missing query. Try: fcontent --help"
case "$OUTPUT" in pretty|paths|json) ;; *) die "Invalid --output: $OUTPUT" ;; esac
[[ "$MAX_MATCHES" =~ ^[0-9]+$ ]] || die "-m/--max-matches must be an integer"
[[ "$MAX_FILES" =~ ^[0-9]+$ ]] || die "-n/--max-files must be an integer"

has rg || die "rg (ripgrep) is required. Run: fcontent --install-hints"

# -------------------------
# Metacharacter warning detection
# -------------------------
_has_regex_metachar() {
  local q="$1"
  # Check for common regex metacharacters: ( ) [ ] { } * + ? ^ $ | \
  # Using glob pattern since bracket expressions in regex are tricky
  [[ "$q" == *[\(\)\[\]\{\}*+?^\$\|\\]* ]]
}

_METACHAR_WARNING=0
_METACHAR_WARNING_MSG="Query contains regex metacharacters. Consider --rg-args '-F' for literal search."

if _has_regex_metachar "$QUERY"; then
  _METACHAR_WARNING=1
  # Suppress warning if -F or --fixed-strings already in RG_ARGS
  for _arg in "${RG_ARGS[@]+"${RG_ARGS[@]}"}"; do
    case "$_arg" in
      -F|--fixed-strings) _METACHAR_WARNING=0; break ;;
    esac
  done
fi

# -------------------------
# Determine input: stdin file list vs directory mode
# -------------------------
# If the user explicitly gave a path (positional or --path that isn't the
# default "."), always use directory mode.  Only treat a non-terminal stdin
# as a piped file list when no explicit path was provided.
EXPLICIT_PATH=0
if [[ -n "${POSITIONAL[1]:-}" ]] || [[ "$SEARCH_PATH" != "$DEFAULT_PATH" ]]; then
  EXPLICIT_PATH=1
fi

FILES_FROM_STDIN=0
if (( EXPLICIT_PATH == 0 )) && ! [ -t 0 ]; then
  FILES_FROM_STDIN=1
fi

# Build file list if using stdin
TMP_LIST=""
cleanup() {
  [[ -n "$TMP_LIST" && -f "$TMP_LIST" ]] && rm -f "$TMP_LIST" || true
}
trap '_exit_code=$?; _TELEM_EXIT_CODE=$_exit_code; _fsuite_record_telemetry; cleanup; exit $_exit_code' EXIT

if (( FILES_FROM_STDIN == 1 )); then
  TMP_LIST="$(mktemp)"
  # Read up to MAX_FILES lines, drop empties, keep as-is
  awk 'NF{print}' | head -n "$MAX_FILES" > "$TMP_LIST"

  if [[ ! -s "$TMP_LIST" ]]; then
    die "No file paths received on stdin."
  fi

  # Infer project from first file path when piped and no explicit --project-name
  if [[ -z "$_TELEM_PROJECT_NAME" ]]; then
    _first_file=$(head -1 "$TMP_LIST" 2>/dev/null) || true
    if [[ -n "${_first_file:-}" ]] && [[ -e "$_first_file" ]]; then
      _infer_dir=$(cd "$(dirname "$_first_file")" 2>/dev/null && pwd) || _infer_dir=""
      if [[ -n "$_infer_dir" ]]; then
        _walk="$_infer_dir"
        while [[ "$_walk" != "/" ]]; do
          if [[ -d "$_walk/.git" ]] || [[ -f "$_walk/package.json" ]] || \
             [[ -f "$_walk/Cargo.toml" ]] || [[ -f "$_walk/go.mod" ]] || \
             [[ -f "$_walk/pyproject.toml" ]]; then
            SEARCH_PATH="$_walk"
            break
          fi
          _walk=$(dirname "$_walk")
        done
        [[ "$SEARCH_PATH" == "$DEFAULT_PATH" ]] && SEARCH_PATH="$_infer_dir"
      fi
    fi
  fi
fi

# -------------------------
# Run rg
# -------------------------
# We'll gather matches in a controlled way:
# - In pretty/json: collect up to MAX_MATCHES lines from rg output
# - In paths: output unique file paths

# Common rg flags:
# --no-messages: suppress permission noise
# --with-filename --line-number: useful metadata
BASE_RG=(rg --no-messages --with-filename --line-number)

# RG_ARGS is already an array (populated by --rg-args flags)

if [[ "$OUTPUT" == "paths" ]]; then
  if (( FILES_FROM_STDIN == 1 )); then
    xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" 2>/dev/null | sort -u || true
  else
    "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | sort -u || true
  fi
  # Emit metacharacter warning to stderr (paths mode)
  (( _METACHAR_WARNING == 1 )) && echo "Warning: $_METACHAR_WARNING_MSG" >&2
  exit 0
fi

# For pretty/json, we want match lines
# || true: rg returns 1 on no matches; head can cause SIGPIPE under pipefail
if (( FILES_FROM_STDIN == 1 )); then
  mapfile -t MATCH_LINES < <(xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -- "$QUERY" 2>/dev/null | head -n "$MAX_MATCHES" || true)
else
  mapfile -t MATCH_LINES < <("${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | head -n "$MAX_MATCHES" || true)
fi

# Extract unique matched filenames from MATCH_LINES (avoids redundant rg invocation).
# rg output format: filename:linenum:content
# Regex handles filenames containing colons (matches first colon followed by digits).
mapfile -t MATCH_FILES < <(
  for line in "${MATCH_LINES[@]+"${MATCH_LINES[@]}"}"; do
    if [[ "$line" =~ ^(.+):([0-9]+): ]]; then
      printf '%s\n' "${BASH_REMATCH[1]}"
    fi
  done | sort -u || true
)

SHOWN_MATCHES="${#MATCH_LINES[@]}"
TOTAL_FILES="${#MATCH_FILES[@]}"

# TOTAL_FILES defaults to MATCH_FILES (derived from MATCH_LINES).
# If we likely truncated matches, recompute TOTAL_FILES from the full rg pass.
# Keep SHOWN_MATCHES as the capped number from MATCH_LINES.
if (( SHOWN_MATCHES == MAX_MATCHES )); then
  if (( FILES_FROM_STDIN == 1 )); then
    mapfile -t FULL_MATCH_FILES < <(
      xargs -d '\n' -a "$TMP_LIST" "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" 2>/dev/null | sort -u || true
    )
  else
    mapfile -t FULL_MATCH_FILES < <(
      "${BASE_RG[@]}" ${RG_ARGS[@]+"${RG_ARGS[@]}"} -l -- "$QUERY" "$SEARCH_PATH" 2>/dev/null | sort -u || true
    )
  fi
  MATCH_FILES=("${FULL_MATCH_FILES[@]}")
  TOTAL_FILES="${#FULL_MATCH_FILES[@]}"
fi

if [[ "$OUTPUT" == "json" ]]; then
  echo -n "{"
  echo -n "\"tool\":\"fcontent\","
  echo -n "\"version\":\"$VERSION\","
  echo -n "\"query\":\"$(printf "%s" "$QUERY" | json_escape)\","
  if (( FILES_FROM_STDIN == 1 )); then
    echo -n "\"mode\":\"stdin_files\","
  else
    echo -n "\"mode\":\"directory\","
    echo -n "\"path\":\"$(printf "%s" "$SEARCH_PATH" | json_escape)\","
  fi
  echo -n "\"total_matched_files\":$TOTAL_FILES,"
  echo -n "\"shown_matches\":$SHOWN_MATCHES,"
  echo -n "\"matches\":["
  for ((i=0; i<SHOWN_MATCHES; i++)); do
    line="$(printf "%s" "${MATCH_LINES[i]}" | json_escape)"
    if (( i > 0 )); then echo -n ","; fi
    echo -n "\"$line\""
  done
  echo -n "],"
  echo -n "\"matched_files\":["
  for ((i=0; i<TOTAL_FILES && i<200; i++)); do
    f="$(printf "%s" "${MATCH_FILES[i]}" | json_escape)"
    if (( i > 0 )); then echo -n ","; fi
    echo -n "\"$f\""
  done
  echo -n "]"
  # Add warning field in JSON output if metacharacter detected
  if (( _METACHAR_WARNING == 1 )); then
    echo -n ",\"warning\":\"$_METACHAR_WARNING_MSG\""
  fi
  echo -n "}"
  echo
  exit 0
fi

# pretty output
if (( QUIET == 0 )); then
  echo "ContentSearch(query: \"$QUERY\")"
  if (( FILES_FROM_STDIN == 1 )); then
    echo "  ⎿ mode: stdin_files (max_files=$MAX_FILES)"
  else
    echo "  ⎿ mode: directory path=\"$SEARCH_PATH\""
  fi
  echo "  ⎿ matched_files: $TOTAL_FILES"
  echo "  ⎿ shown_matches: $SHOWN_MATCHES (cap=$MAX_MATCHES)"
fi
if (( SHOWN_MATCHES == 0 )); then
  # Emit metacharacter warning to stderr (pretty mode)
  (( _METACHAR_WARNING == 1 )) && echo "Warning: $_METACHAR_WARNING_MSG" >&2
  exit 0
fi
for line in "${MATCH_LINES[@]}"; do
  if (( QUIET == 1 )); then
    echo "$line"
  else
    echo "     $line"
  fi
done
# Emit metacharacter warning to stderr (pretty mode)
(( _METACHAR_WARNING == 1 )) && echo "Warning: $_METACHAR_WARNING_MSG" >&2
