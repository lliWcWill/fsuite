#!/usr/bin/env bash
# ftree — smart directory snapshot with recon mode, agent-friendly output.
# Part of fsuite. Wraps tree(1) + find/du/stat for context-budget-aware directory views.

set -euo pipefail

VERSION="1.5.0"

# -------------------------
# Source common library for tiered telemetry
# -------------------------
_FSUITE_SCRIPT_DIR="$(cd "$(dirname "$(realpath "$0" 2>/dev/null || readlink -f "$0" 2>/dev/null || echo "$0")")" && pwd)"
_FSUITE_LIB="$_FSUITE_SCRIPT_DIR/_fsuite_common.sh"
[[ ! -f "$_FSUITE_LIB" ]] && _FSUITE_LIB="/usr/share/fsuite/_fsuite_common.sh"
[[ -f "$_FSUITE_LIB" ]] && source "$_FSUITE_LIB" || true

# -------------------------
# Telemetry — opt-out via FSUITE_TELEMETRY=0
# Tiers: 0=disabled, 1=timing+bytes, 2=+hardware, 3=+profile
# -------------------------
_FSUITE_TELEM="${FSUITE_TELEMETRY:-1}"
[[ "$_FSUITE_TELEM" =~ ^[0-9]+$ ]] || _FSUITE_TELEM=1
_TELEM_START_MS=$(date +%s%3N 2>/dev/null || echo 0)
_TELEM_EXIT_CODE=0
_TELEM_BYTES=-1
_TELEM_FLAGS=""
_TELEM_PROJECT_NAME=""

_fsuite_record_telemetry() {
  _TELEM_EXIT_CODE=$?
  (( _FSUITE_TELEM >= 1 )) || return 0
  [[ "$_TELEM_START_MS" != "0" ]] || return 0
  [[ "$_TELEM_START_MS" =~ ^[0-9]+$ ]] || return 0
  local end_ms
  end_ms=$(date +%s%3N 2>/dev/null || echo 0)
  [[ "$end_ms" != "0" ]] || return 0
  [[ "$end_ms" =~ ^[0-9]+$ ]] || return 0
  local dur_ms=$(( end_ms - _TELEM_START_MS ))
  (( dur_ms < 0 )) && dur_ms=0
  local telem_dir="$HOME/.fsuite"
  mkdir -p "$telem_dir" 2>/dev/null || return 0
  local ts
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || echo "unknown")
  local ph=""
  if [[ -n "${ABS_TARGET:-}" ]]; then
    ph=$(printf "%s" "$ABS_TARGET" | sha256sum 2>/dev/null | cut -c1-16) || true
    [[ -z "$ph" ]] && ph="unknown"
  fi
  # Sanitize project name: alphanumeric + safe chars, then JSON-escape
  local pn=""
  if [[ -n "${ABS_TARGET:-}" ]]; then
    pn=$(basename "$ABS_TARGET" | tr -cd '[:alnum:]. _-')
    # JSON-escape any remaining special chars (backslash, quotes)
    pn=$(printf '%s' "$pn" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')
  fi
  if [[ -n "${_TELEM_PROJECT_NAME:-}" ]]; then
    pn=$(printf '%s' "$_TELEM_PROJECT_NAME" | tr -cd '[:alnum:]. _-')
  fi
  local mode="tree"
  (( ${SNAPSHOT:-0} == 1 )) && mode="snapshot"
  (( ${RECON:-0} == 1 )) && mode="recon"
  local items=${_TELEM_ITEMS:--1}
  if (( items == -1 )) && [[ -n "${TREE_FILES:-}" ]] && (( TREE_FILES + TREE_DIRS > 0 )); then
    items=$((TREE_FILES + TREE_DIRS))
  fi
  # Compute bytes_scanned using du_bytes if not already set
  if [[ "$_TELEM_BYTES" -eq -1 ]] && [[ -n "${ABS_TARGET:-}" ]] && [[ -d "$ABS_TARGET" ]]; then
    _TELEM_BYTES=$(du_bytes "$ABS_TARGET")
  fi
  # Collect hardware telemetry if tier >= 2
  if type _fsuite_collect_hw_telemetry &>/dev/null; then
    _fsuite_collect_hw_telemetry "$_FSUITE_TELEM" "${ABS_TARGET:-}"
  fi
  local _hw_fields=""
  if type _fsuite_hw_json_fields &>/dev/null && (( _FSUITE_TELEM >= 2 )); then
    _hw_fields=$(_fsuite_hw_json_fields "$_FSUITE_TELEM")
    [[ -n "$_hw_fields" ]] && _hw_fields=",${_hw_fields}"
  fi
  local _safe_flags
  _safe_flags=$(printf '%s' "${_TELEM_FLAGS# }" | tr -cd '[:alnum:] _./-' | head -c 200)
  local _telem_line="{\"timestamp\":\"$ts\",\"tool\":\"ftree\",\"version\":\"$VERSION\",\"mode\":\"$mode\",\"path_hash\":\"$ph\",\"project_name\":\"$pn\",\"duration_ms\":$dur_ms,\"exit_code\":$_TELEM_EXIT_CODE,\"depth\":${DEPTH:-3},\"items_scanned\":$items,\"bytes_scanned\":${_TELEM_BYTES},\"flags\":\"$_safe_flags\",\"backend\":\"${mode}\"${_hw_fields}}"
  # Atomic append with flock to prevent interleaved writes
  {
    flock -x 200 2>/dev/null
    echo "$_telem_line" >> "$telem_dir/telemetry.jsonl"
  } 200>"$telem_dir/.telemetry.lock" 2>/dev/null || true
}
trap '_fsuite_record_telemetry' EXIT

# -------------------------
# Defaults (override via flags)
# -------------------------
DEFAULT_IGNORE="node_modules|.git|venv|.venv|__pycache__|dist|build|.next|.cache|vendor|target|.gradle|.idea|.vscode|*.egg-info|.tox|.mypy_cache|.pytest_cache|.DS_Store|.terraform"
DEFAULT_DEPTH=3
DEFAULT_MAX_LINES=200
DEFAULT_FILELIMIT=80
DEFAULT_OUTPUT="pretty"   # pretty|paths|json
DEFAULT_RECON_DEPTH=1
DEFAULT_BUDGET=30          # wall-clock seconds for recon scan

# -------------------------
# Helpers
# -------------------------
die() {
  local code=2
  if [[ "${1:-}" =~ ^[0-9]+$ ]]; then code="$1"; shift; fi
  echo "ftree: $*" >&2
  exit "$code"
}

has() { command -v "$1" >/dev/null 2>&1; }

json_escape() {
  sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\t/\\t/g' -e 's/\r/\\r/g' -e ':a;N;$!ba;s/\n/\\n/g'
}

tree_supports_gitignore() {
  tree --help 2>&1 | grep -q '\-\-gitignore'
}

du_bytes() {
  local p="$1" out rc
  LAST_OP_TIMED_OUT=0
  if ! has timeout; then
    LAST_OP_TIMED_OUT=1; printf "%s" "-1"; return
  fi
  out=$(timeout 3 du -sb "$p" 2>/dev/null) || rc=$?
  if [[ "${rc:-0}" -eq 124 ]]; then
    LAST_OP_TIMED_OUT=1; printf "%s" "-1"; return
  fi
  out="${out%%	*}"  # strip trailing tab+path (du output: SIZE\tPATH)
  if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then printf "%s" "$out"; return; fi
  rc=0
  out=$(timeout 3 du -sk "$p" 2>/dev/null) || rc=$?
  if [[ "${rc:-0}" -eq 124 ]]; then
    LAST_OP_TIMED_OUT=1; printf "%s" "-1"; return
  fi
  out="${out%%	*}"
  if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then printf "%s" "$(( out * 1024 ))"; return; fi
  printf "%s" "-1"
}

count_items_total() {
  local p="$1" n pipe_rc
  LAST_OP_TIMED_OUT=0
  if ! has timeout; then
    LAST_OP_TIMED_OUT=1; printf "%s" "-1"; return
  fi
  set +e
  n=$(timeout 3 find "$p" -mindepth 1 2>/dev/null | wc -l)
  pipe_rc="${PIPESTATUS[0]}"
  set -e
  if [[ "$pipe_rc" -eq 124 ]]; then
    LAST_OP_TIMED_OUT=1; printf "%s" "-1"; return
  fi
  n="${n//[[:space:]]/}"
  if [[ "$n" == "" ]] || ! [[ "$n" =~ ^[0-9]+$ ]]; then n="-1"; fi
  printf "%s" "$n"
}

count_items_shallow() {
  # Count immediate children only (for excluded dirs — avoids deep traversal).
  local p="$1" n
  n=$(ls -1A "$p" 2>/dev/null | wc -l) || n="0"
  n="${n//[[:space:]]/}"
  if [[ "$n" == "" ]] || ! [[ "$n" =~ ^[0-9]+$ ]]; then n="0"; fi
  printf "%s" "$n"
}

stat_bytes() {
  local p="$1" out
  out=$(stat --format='%s' "$p" 2>/dev/null)
  if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then printf "%s" "$out"; return; fi
  out=$(stat -f '%z' "$p" 2>/dev/null)
  if [[ -n "$out" && "$out" =~ ^[0-9]+$ ]]; then printf "%s" "$out"; return; fi
  printf "%s" "-1"
}

# bytes → human-readable (K/M/G) using pure bash arithmetic + printf
human_size() {
  local bytes="$1"
  if (( bytes < 0 )); then
    printf "?"
    return
  fi
  if (( bytes < 1024 )); then
    printf "%d" "$bytes"
  elif (( bytes < 1048576 )); then
    local whole=$(( bytes / 1024 ))
    local frac=$(( ((bytes % 1024) * 10 + 512) / 1024 ))
    if (( frac >= 10 )); then whole=$(( whole + 1 )); frac=0; fi
    if (( frac == 0 )); then printf "%dK" "$whole"
    else printf "%d.%dK" "$whole" "$frac"; fi
  elif (( bytes < 1073741824 )); then
    local whole=$(( bytes / 1048576 ))
    local frac=$(( ((bytes % 1048576) * 10 + 524288) / 1048576 ))
    if (( frac >= 10 )); then whole=$(( whole + 1 )); frac=0; fi
    if (( frac == 0 )); then printf "%dM" "$whole"
    else printf "%d.%dM" "$whole" "$frac"; fi
  else
    local whole=$(( bytes / 1073741824 ))
    local frac=$(( ((bytes % 1073741824) * 10 + 536870912) / 1073741824 ))
    if (( frac >= 10 )); then whole=$(( whole + 1 )); frac=0; fi
    if (( frac == 0 )); then printf "%dG" "$whole"
    else printf "%d.%dG" "$whole" "$frac"; fi
  fi
}

# Check if a basename matches the pipe-separated ignore pattern.
# Returns 0 (match) or 1 (no match).
name_matches_ignore() {
  local name="$1"
  local pattern="$2"
  [[ -z "$pattern" ]] && return 1

  local IFS='|'
  local tok
  for tok in $pattern; do
    [[ -z "$tok" ]] && continue
    # Support glob wildcards in tokens (e.g. *.egg-info)
    # shellcheck disable=SC2254
    case "$name" in
      $tok) return 0 ;;
    esac
  done
  return 1
}

usage() {
  cat <<'EOF'
ftree — smart directory snapshot with recon mode (agent-friendly)

USAGE
  ftree [OPTIONS] [path]

QUICK EXAMPLES
  # Show tree of current directory (depth 3, default excludes)
  ftree

  # Recon: per-directory item counts and sizes
  ftree --recon /project

  # JSON output for agents
  ftree -o json /project

  # Flat file list (pipe-friendly)
  ftree -o paths /project

  # Drill into a subdirectory with deeper view
  ftree -L 5 /project/src

  # Include a normally-excluded directory
  ftree --include .git /project

  # Recon without excluded-directory summaries
  ftree --recon --hide-excluded /project

OPTIONS
  -o, --output pretty|paths|json
      pretty: human-friendly tree with header + truncation (default)
      paths:  flat file list, one per line (best for piping)
      json:   structured JSON (best for AI agents)

  -L, --depth N
      Max tree depth. Default: 3

  -m, --max-lines N
      Truncate pretty output at N lines (0 = unlimited). Default: 200
      Does not apply to paths or json output.

  -q, --quiet
      Suppress header line. Useful for piping/scripting.

  -F, --filelimit N
      Limit entries listed per directory. Default: 80
      tree may annotate directories when entries exceed this limit.

  -I, --ignore 'PATTERN'
      Additional pipe-separated patterns to exclude (appended to defaults).
      Always quote the value: ftree -I 'docs|*.md' /project

  --no-default-ignore
      Disable the built-in ignore list (node_modules, .git, venv, etc.).

  --include PATTERN
      Promote an excluded dir back to normal treatment (repeatable).
      Exact basename match: --include node_modules (not partial regex).

  -r, --recon
      Recon mode: shallow scan with per-directory item counts and sizes.
      Does not use tree(1) — uses find/du/stat directly.

  --recon-depth N
      How deep recon scans. Default: 1 (2 in snapshot mode). Deeper is expensive.

  --budget N
      Max wall-clock seconds for recon scans. Default: 30.
      Each du/find call has a 3-second per-call timeout.
      When budget is exceeded, remaining entries become stubs (items=-1, size=-1).
      JSON output includes "partial": true, "heavy": true on timed-out entries.

  --snapshot
      Snapshot mode: combines recon inventory and tree excerpt in one output.
      Default recon depth: 2. Not compatible with --recon or -o paths.

  --no-lines
      In snapshot JSON, omit the tree.lines array (keeps tree_json only).
      Only valid with --snapshot -o json.

  --project-name <name>
      Override project name in telemetry.

  --hide-excluded
      Suppress excluded-directory summaries from recon output.

  -d, --dirs-only
      Show only directories (applies to both tree and recon modes).

  -s, --sizes
      Show file/directory sizes in tree output.

  --gitignore
      Also honor .gitignore rules. Guarded: warns if tree version lacks support.

  -f, --full-paths
      Print full path prefix for each entry.

  --self-check
      Verify tree is installed and check --gitignore support.

  --install-hints
      Print install commands for tree.

  -h, --help
      Show this help and exit.

  --version
      Print version and exit.

DEFAULT IGNORE LIST
  node_modules|.git|venv|.venv|__pycache__|dist|build|.next|.cache|
  vendor|target|.gradle|.idea|.vscode|*.egg-info|.tox|.mypy_cache|
  .pytest_cache|.DS_Store|.terraform

  --ignore appends to defaults. --no-default-ignore disables them.
  --include removes exact tokens from the list.

EXIT CODES
  0  Success (even if empty tree / no results)
  2  Usage error (bad flags, missing args)
  3  Missing dependency (tree not installed)

RECON MODE
  Recon scans the target directory with find/du/stat instead of tree.
  For each entry: directories get an item count and size; files get size.
  Excluded directories (matching the ignore list) are shown separately,
  tagged [default-excluded], unless --hide-excluded is used.

  items_total: count of all entries (files + dirs) under a directory.

AGENT / HEADLESS USAGE
  ftree -o json /project             # structured tree JSON
  ftree --recon -o json /project     # per-dir inventory JSON
  ftree --snapshot -o json /project  # combined recon + tree in one call
  ftree -o paths /project            # flat file list for piping

  Agent drill-down workflow:
    1. ftree --snapshot /project         # one-shot: recon + tree
    2. ftree -L 5 /project/src           # zoom: deeper into src/

EOF
}

print_install_hints() {
  cat <<'EOF'
Install tree:

Debian/Ubuntu:
  sudo apt update && sudo apt install -y tree

Tip: authenticate once first (helps if doing multiple installs):
  sudo -v
EOF
}

# -------------------------
# Parse args
# -------------------------
TARGET=""
OUTPUT="$DEFAULT_OUTPUT"
DEPTH="$DEFAULT_DEPTH"
MAX_LINES="$DEFAULT_MAX_LINES"
FILELIMIT="$DEFAULT_FILELIMIT"
USER_IGNORE=""
NO_DEFAULT_IGNORE=0
INCLUDES=()
RECON=0
RECON_DEPTH="$DEFAULT_RECON_DEPTH"
HIDE_EXCLUDED=0
DIRS_ONLY=0
SIZES=0
GITIGNORE=0
FULL_PATHS=0
SNAPSHOT=0
SELF_CHECK=0
INSTALL_HINTS=0
RECON_DEPTH_SET=0
BUDGET="$DEFAULT_BUDGET"
QUIET=0
NO_LINES=0

# Pre-process arguments: expand combined short flags like -L3 to -L 3
_args=()
for _arg in "$@"; do
  if [[ "$_arg" =~ ^-([LmF])([0-9]+)$ ]]; then
    _args+=("-${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
  else
    _args+=("$_arg")
  fi
done
set -- "${_args[@]}"

POSITIONAL=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -q|--quiet) QUIET=1; _TELEM_FLAGS+=" -q"; shift ;;
    -o|--output)
      shift; [[ $# -gt 0 ]] || die "Missing value for --output"
      OUTPUT="$1"; shift ;;
    -L|--depth)
      shift; [[ $# -gt 0 ]] || die "Missing value for --depth"
      DEPTH="$1"; _TELEM_FLAGS+=" -L $DEPTH"; shift ;;
    -m|--max-lines)
      shift; [[ $# -gt 0 ]] || die "Missing value for --max-lines"
      MAX_LINES="$1"; _TELEM_FLAGS+=" -m $MAX_LINES"; shift ;;
    -F|--filelimit)
      shift; [[ $# -gt 0 ]] || die "Missing value for --filelimit"
      FILELIMIT="$1"; _TELEM_FLAGS+=" -F $FILELIMIT"; shift ;;
    -I|--ignore)
      shift; [[ $# -gt 0 ]] || die "Missing value for --ignore"
      USER_IGNORE="${USER_IGNORE:+$USER_IGNORE|}$1"; shift ;;
    --no-default-ignore) NO_DEFAULT_IGNORE=1; _TELEM_FLAGS+=" --no-default-ignore"; shift ;;
    --include)
      shift; [[ $# -gt 0 ]] || die "Missing value for --include"
      INCLUDES+=("$1"); _TELEM_FLAGS+=" --include"; shift ;;
    -r|--recon)        RECON=1; shift ;;
    --snapshot)        SNAPSHOT=1; shift ;;
    --no-lines)        NO_LINES=1; _TELEM_FLAGS+=" --no-lines"; shift ;;
    --recon-depth)
      shift; [[ $# -gt 0 ]] || die "Missing value for --recon-depth"
      RECON_DEPTH="$1"; _TELEM_FLAGS+=" --recon-depth $RECON_DEPTH"; RECON_DEPTH_SET=1; shift ;;
    --budget)
      shift; [[ $# -gt 0 ]] || die "Missing value for --budget"
      BUDGET="$1"; _TELEM_FLAGS+=" --budget $BUDGET"; shift ;;
    --hide-excluded)   HIDE_EXCLUDED=1; _TELEM_FLAGS+=" --hide-excluded"; shift ;;
    -d|--dirs-only)    DIRS_ONLY=1; _TELEM_FLAGS+=" -d"; shift ;;
    -s|--sizes)        SIZES=1; _TELEM_FLAGS+=" -s"; shift ;;
    --gitignore)       GITIGNORE=1; _TELEM_FLAGS+=" --gitignore"; shift ;;
    -f|--full-paths)   FULL_PATHS=1; shift ;;
    --project-name)
      shift; [[ $# -gt 0 ]] || die "Missing value for --project-name"
      _TELEM_PROJECT_NAME="$1"; shift ;;
    --self-check)      SELF_CHECK=1; shift ;;
    --install-hints)   INSTALL_HINTS=1; shift ;;
    -h|--help)         usage; exit 0 ;;
    --version)         echo "ftree $VERSION"; exit 0 ;;
    --)                shift; break ;;
    -*)                die "Unknown option: $1 (try --help)" ;;
    *)                 POSITIONAL+=("$1"); shift ;;
  esac
done

# Append remaining args after --
while [[ $# -gt 0 ]]; do POSITIONAL+=("$1"); shift; done

TARGET="${POSITIONAL[0]:-}"
TARGET="${TARGET:-.}"

# -------------------------
# Special modes
# -------------------------
if (( INSTALL_HINTS == 1 )); then
  print_install_hints
  exit 0
fi

if (( SELF_CHECK == 1 )); then
  echo "Self-check:"
  echo "  Requires: tree. Uses: find, du, stat."
  _SELF_CHECK_OK=1
  if has tree; then
    echo "  ✓ tree available ($(command -v tree))"
    if tree_supports_gitignore; then
      echo "  ✓ tree supports --gitignore"
    else
      echo "  ✗ tree does not support --gitignore (need tree >= 1.8.0)"
    fi
  else
    echo "  ✗ tree not found. Run: ftree --install-hints"
    _SELF_CHECK_OK=0
  fi
  echo ""
  echo "If installing packages and you want fewer sudo prompts:"
  echo "  sudo -v"
  if (( _SELF_CHECK_OK == 0 )); then
    exit 3
  fi
  exit 0
fi

# -------------------------
# Validation
# -------------------------
case "$OUTPUT" in pretty|paths|json) ;; *) die "Invalid --output: $OUTPUT" ;; esac
[[ "$DEPTH" =~ ^[0-9]+$ ]]      || die "--depth must be an integer"
[[ "$MAX_LINES" =~ ^[0-9]+$ ]]  || die "--max-lines must be an integer"
[[ "$FILELIMIT" =~ ^[0-9]+$ ]]  || die "--filelimit must be an integer"
[[ "$RECON_DEPTH" =~ ^[0-9]+$ ]] || die "--recon-depth must be an integer"
[[ "$BUDGET" =~ ^[0-9]+$ ]]      || die "--budget must be an integer"

(( SNAPSHOT == 1 && RECON == 1 )) && die "--snapshot and --recon are mutually exclusive"
(( SNAPSHOT == 1 )) && [[ "$OUTPUT" == "paths" ]] && die "--snapshot is not compatible with -o paths"

if (( NO_LINES == 1 )); then
  (( SNAPSHOT == 0 )) && die "--no-lines is only valid with --snapshot"
  [[ "$OUTPUT" != "json" ]] && die "--no-lines is only meaningful with -o json"
fi

# Seed telemetry flags with defaults
(( RECON == 1 )) && _TELEM_FLAGS+=" --recon"
(( SNAPSHOT == 1 )) && _TELEM_FLAGS+=" --snapshot"
_TELEM_FLAGS+=" -o ${OUTPUT:-pretty}"

[[ -e "$TARGET" ]] || die "Path does not exist: $TARGET"

# Always resolve absolute path for metadata (headers, JSON path, drill-down).
# Uses logical pwd (preserves symlinks) — not pwd -P (canonical).
# Keep original TARGET for tree(1) invocation (controls path display in tree body).
ABS_TARGET="$(cd "$TARGET" 2>/dev/null && pwd)" || ABS_TARGET="$(readlink -f "$TARGET" 2>/dev/null || echo "$TARGET")"

# If --full-paths, also use absolute path for tree invocation
if (( FULL_PATHS == 1 )); then
  TARGET="$ABS_TARGET"
fi

# Snapshot mode: default recon depth is 2 (deeper context capture)
if (( SNAPSHOT == 1 && RECON_DEPTH_SET == 0 )); then
  RECON_DEPTH=2
fi

# -------------------------
# Build ignore pattern
# -------------------------
build_ignore() {
  local combined=""
  if (( NO_DEFAULT_IGNORE == 0 )); then
    combined="$DEFAULT_IGNORE"
  fi
  if [[ -n "$USER_IGNORE" ]]; then
    combined="${combined:+$combined|}$USER_IGNORE"
  fi
  [[ -z "$combined" ]] && { printf ""; return 0; }

  IFS='|' read -r -a toks <<< "$combined"
  local -a out=()
  local tok inc keep
  for tok in "${toks[@]}"; do
    [[ -z "$tok" ]] && continue
    keep=1
    for inc in "${INCLUDES[@]+"${INCLUDES[@]}"}"; do
      [[ -z "$inc" ]] && continue
      [[ "$tok" == "$inc" ]] && { keep=0; break; }
    done
    (( keep )) && out+=("$tok")
  done

  local joined=""
  for tok in "${out[@]+"${out[@]}"}"; do
    joined="${joined:+$joined|}$tok"
  done
  printf "%s" "$joined"
}

IGNORE_PATTERN="$(build_ignore)"

# -------------------------
# Recon mode
# -------------------------
run_recon() {
  [[ -d "$TARGET" ]] || die "Not a directory: $TARGET"

  local entries=()
  local entry name type items_total size_bytes excluded

  # Collect entries at target, up to recon_depth
  # For depth 1, just ls the target directory
  if (( RECON_DEPTH == 1 )); then
    # List immediate children
    while IFS= read -r -d '' entry; do
      entries+=("$entry")
    done < <(find "$TARGET" -mindepth 1 -maxdepth 1 -print0 2>/dev/null)
  else
    # Deeper recon: list entries up to recon_depth
    while IFS= read -r -d '' entry; do
      entries+=("$entry")
    done < <(find "$TARGET" -mindepth 1 -maxdepth "$RECON_DEPTH" -print0 2>/dev/null)
  fi

  # For each entry, gather metadata
  local visible_dirs=()
  local visible_files=()
  local excluded_entries=()

  # Budget tracking
  SECONDS=0
  BUDGET_EXCEEDED=0
  BUDGET_USED=0
  LAST_OP_TIMED_OUT=0

  for entry in "${entries[@]+"${entries[@]}"}"; do
    # Check budget before each entry
    if (( BUDGET_EXCEEDED == 0 )) && (( SECONDS >= BUDGET )); then
      BUDGET_EXCEEDED=1
      BUDGET_USED=$SECONDS
    fi

    name="$(basename "$entry")"
    excluded=false
    items_total=0
    size_bytes=-1
    local heavy=false
    local reason=""

    # Check against ignore pattern
    if [[ -n "$IGNORE_PATTERN" ]] && name_matches_ignore "$name" "$IGNORE_PATTERN"; then
      excluded=true
    fi

    if (( BUDGET_EXCEEDED == 1 )); then
      # Budget exceeded: stub mode — skip expensive operations
      reason="budget_exceeded"
      if [[ -d "$entry" ]]; then
        type="directory"; items_total=-1; size_bytes=-1; heavy=true
      elif [[ -f "$entry" ]]; then
        type="file"; items_total=0; size_bytes=-1; heavy=true
      else
        type="other"; items_total=0; size_bytes=-1; heavy=true
      fi
    elif [[ -d "$entry" ]]; then
      type="directory"
      if [[ "$excluded" == "true" ]]; then
        # Excluded dirs: shallow count only, skip expensive du
        items_total="$(count_items_shallow "$entry")"
        size_bytes=-1
        reason="excluded"
      else
        # Visible dirs: full scan with per-call timeouts
        LAST_OP_TIMED_OUT=0
        items_total="$(count_items_total "$entry")"
        local count_timed_out=$LAST_OP_TIMED_OUT

        LAST_OP_TIMED_OUT=0
        size_bytes="$(du_bytes "$entry")"
        local du_timed_out=$LAST_OP_TIMED_OUT

        if (( count_timed_out == 1 )) || (( du_timed_out == 1 )); then
          heavy=true
          reason="timeout"
        fi
      fi
    elif [[ -f "$entry" ]]; then
      type="file"
      items_total=0
      size_bytes="$(stat_bytes "$entry")"
      [[ "$size_bytes" == "-1" ]] && reason="stat_failed"
    else
      type="other"
      items_total=0
      size_bytes=-1
      reason="stat_failed"
    fi

    # Skip files in dirs-only mode
    if (( DIRS_ONLY == 1 )) && [[ "$type" != "directory" ]]; then
      continue
    fi

    # Store as: name|type|items_total|size_bytes|excluded|heavy|reason
    local record="${name}|${type}|${items_total}|${size_bytes}|${excluded}|${heavy}|${reason}"

    if [[ "$excluded" == "true" ]]; then
      excluded_entries+=("$record")
    elif [[ "$type" == "directory" ]]; then
      visible_dirs+=("$record")
    else
      visible_files+=("$record")
    fi
  done

  # Capture final budget usage
  if (( BUDGET_EXCEEDED == 0 )); then
    BUDGET_USED=$SECONDS
  fi

  # Sort by size descending (within each group)
  # Use a simple bubble approach via sort on the size field
  sort_records_by_size() {
    local arr=("$@")
    local i rec size_val
    # Print records with sortable size prefix, then strip prefix
    for rec in "${arr[@]+"${arr[@]}"}"; do
      size_val="$(cut -d'|' -f4 <<<"$rec")"
      # Unreadable entries sort after readable: use -1 → maps to very low
      if (( size_val < 0 )); then
        printf "%020d|%s\n" "0" "$rec"
      else
        printf "%020d|%s\n" "$size_val" "$rec"
      fi
    done | sort -t'|' -k1,1rn -k2,2 | cut -d'|' -f2-
  }

  local sorted_vis_dirs=() sorted_vis_files=() sorted_excluded=()
  if (( ${#visible_dirs[@]} > 0 )); then
    mapfile -t sorted_vis_dirs < <(sort_records_by_size "${visible_dirs[@]}")
  fi
  if (( ${#visible_files[@]} > 0 )); then
    mapfile -t sorted_vis_files < <(sort_records_by_size "${visible_files[@]}")
  fi
  if (( ${#excluded_entries[@]} > 0 )); then
    mapfile -t sorted_excluded < <(sort_records_by_size "${excluded_entries[@]}")
  fi

  local total_visible=$(( ${#sorted_vis_dirs[@]} + ${#sorted_vis_files[@]} ))
  local total_excluded=${#sorted_excluded[@]}
  local total_entries=$(( total_visible + total_excluded ))
  _TELEM_ITEMS=$total_entries  # telemetry: capture recon entry count

  # Compute total_size_bytes using du_bytes on TARGET (avoids double-counting at RECON_DEPTH > 1)
  local total_size_bytes=0
  total_size_bytes=$(du_bytes "$TARGET" 2>/dev/null) || total_size_bytes=0
  [[ "$total_size_bytes" =~ ^[0-9]+$ ]] || total_size_bytes=0

  # --- Output ---
  if [[ "$OUTPUT" == "json" ]]; then
    render_recon_json "$total_entries" "$total_visible" "$total_excluded" "$total_size_bytes"
    return
  fi

  if [[ "$OUTPUT" == "paths" ]]; then
    render_recon_paths
    return
  fi

  # Pretty output
  render_recon_pretty "$total_entries" "$total_visible" "$total_excluded"
}

render_recon_pretty() {
  local total_entries="$1" total_visible="$2" total_excluded="$3"

  local budget_info=""
  if (( BUDGET_EXCEEDED == 1 )); then
    budget_info=", budget=${BUDGET}s EXCEEDED, used=${BUDGET_USED}s"
  fi

  echo "Recon($ABS_TARGET, depth=$RECON_DEPTH$budget_info)"
  if (( HIDE_EXCLUDED == 1 )); then
    echo "  ⎿ $total_entries entries ($total_visible visible, $total_excluded default-excluded, hidden)"
  else
    echo "  ⎿ $total_entries entries ($total_visible visible, $total_excluded default-excluded)"
  fi
  echo ""

  local rec name type items size_bytes size_human heavy heavy_mark reason
  # Visible dirs
  for rec in "${sorted_vis_dirs[@]+"${sorted_vis_dirs[@]}"}"; do
    IFS='|' read -r name type items size_bytes _ heavy reason <<< "$rec"
    if (( items < 0 )); then
      items="?"
    fi
    size_human="$(human_size "$size_bytes")"
    heavy_mark=""; [[ "$heavy" == "true" ]] && heavy_mark=" ⏱"
    [[ -n "$reason" && "$reason" != "" ]] && heavy_mark+=" ($reason)"
    printf "  %-24s %6s items  %8s%s\n" "${name}/" "$items" "$size_human" "$heavy_mark"
  done
  # Visible files
  for rec in "${sorted_vis_files[@]+"${sorted_vis_files[@]}"}"; do
    IFS='|' read -r name type items size_bytes _ heavy reason <<< "$rec"
    size_human="$(human_size "$size_bytes")"
    heavy_mark=""; [[ "$heavy" == "true" ]] && heavy_mark=" ⏱"
    [[ -n "$reason" && "$reason" != "" ]] && heavy_mark+=" ($reason)"
    printf "  %-24s %6s        %8s%s\n" "$name" "—" "$size_human" "$heavy_mark"
  done

  # Excluded entries
  if (( HIDE_EXCLUDED == 0 )) && (( total_excluded > 0 )); then
    echo ""
    echo "  [default-excluded]"
    for rec in "${sorted_excluded[@]+"${sorted_excluded[@]}"}"; do
      IFS='|' read -r name type items size_bytes _ heavy reason <<< "$rec"
      if [[ "$type" == "directory" ]]; then
        if (( items < 0 )); then
          items="?"
        fi
        size_human="$(human_size "$size_bytes")"
        heavy_mark=""; [[ "$heavy" == "true" ]] && heavy_mark=" ⏱"
        [[ -n "$reason" && "$reason" != "" ]] && heavy_mark+=" ($reason)"
        printf "  %-24s %6s items  %8s%s\n" "${name}/" "$items" "$size_human" "$heavy_mark"
      else
        size_human="$(human_size "$size_bytes")"
        heavy_mark=""; [[ "$heavy" == "true" ]] && heavy_mark=" ⏱"
        [[ -n "$reason" && "$reason" != "" ]] && heavy_mark+=" ($reason)"
        printf "  %-24s %6s        %8s%s\n" "$name" "—" "$size_human" "$heavy_mark"
      fi
    done
  fi
}

render_recon_json() {
  local total_entries="$1" total_visible="$2" total_excluded="$3" total_size_bytes="${4:-0}"

  echo -n "{"
  echo -n "\"tool\":\"ftree\","
  echo -n "\"version\":\"$VERSION\","
  echo -n "\"mode\":\"recon\","
  echo -n "\"backend\":\"find/du/stat\","
  echo -n "\"path\":\"$(printf "%s" "$ABS_TARGET" | json_escape)\","
  echo -n "\"recon_depth\":$RECON_DEPTH,"
  echo -n "\"budget_seconds\":$BUDGET,"
  echo -n "\"budget_used_seconds\":$BUDGET_USED,"
  if (( BUDGET_EXCEEDED == 1 )); then
    echo -n "\"partial\":true,"
  fi
  echo -n "\"total_entries\":$total_entries,"
  echo -n "\"total_size_bytes\":$total_size_bytes,"
  echo -n "\"visible\":$total_visible,"
  echo -n "\"excluded\":$total_excluded,"
  echo -n "\"entries\":["

  local first=1
  local rec name type items size_bytes excluded size_human heavy reason

  # All visible entries
  for rec in "${sorted_vis_dirs[@]+"${sorted_vis_dirs[@]}"}"; do
    IFS='|' read -r name type items size_bytes excluded heavy reason <<< "$rec"
    size_human="$(human_size "$size_bytes")"
    (( first )) || echo -n ","
    first=0
    echo -n "{\"name\":\"$(printf "%s" "$name" | json_escape)\","
    echo -n "\"type\":\"directory\","
    echo -n "\"items_total\":$items,"
    echo -n "\"size_bytes\":$size_bytes,"
    echo -n "\"size_human\":\"$size_human\","
    if [[ "$heavy" == "true" ]]; then
      echo -n "\"heavy\":true,"
    fi
    if [[ "$size_bytes" == "-1" ]] && [[ -n "$reason" ]]; then
      echo -n "\"reason\":\"$reason\","
    fi
    echo -n "\"excluded\":false}"
  done

  for rec in "${sorted_vis_files[@]+"${sorted_vis_files[@]}"}"; do
    IFS='|' read -r name type items size_bytes excluded heavy reason <<< "$rec"
    size_human="$(human_size "$size_bytes")"
    (( first )) || echo -n ","
    first=0
    echo -n "{\"name\":\"$(printf "%s" "$name" | json_escape)\","
    echo -n "\"type\":\"file\","
    echo -n "\"size_bytes\":$size_bytes,"
    echo -n "\"size_human\":\"$size_human\","
    if [[ "$heavy" == "true" ]]; then
      echo -n "\"heavy\":true,"
    fi
    if [[ "$size_bytes" == "-1" ]] && [[ -n "$reason" ]]; then
      echo -n "\"reason\":\"$reason\","
    fi
    echo -n "\"excluded\":false}"
  done

  # Excluded entries
  if (( HIDE_EXCLUDED == 0 )); then
    for rec in "${sorted_excluded[@]+"${sorted_excluded[@]}"}"; do
      IFS='|' read -r name type items size_bytes excluded heavy reason <<< "$rec"
      size_human="$(human_size "$size_bytes")"
      (( first )) || echo -n ","
      first=0
      echo -n "{\"name\":\"$(printf "%s" "$name" | json_escape)\","
      echo -n "\"type\":\"$type\","
      if [[ "$type" == "directory" ]]; then
        echo -n "\"items_total\":$items,"
      fi
      echo -n "\"size_bytes\":$size_bytes,"
      echo -n "\"size_human\":\"$size_human\","
      if [[ "$heavy" == "true" ]]; then
        echo -n "\"heavy\":true,"
      fi
      if [[ "$size_bytes" == "-1" ]] && [[ -n "$reason" ]]; then
        echo -n "\"reason\":\"$reason\","
      fi
      echo -n "\"excluded\":true}"
    done
  fi

  echo -n "]}"
  echo
}

render_recon_paths() {
  local rec name type excluded reason
  for rec in "${sorted_vis_dirs[@]+"${sorted_vis_dirs[@]}"}"; do
    IFS='|' read -r name type _ _ excluded _ reason <<< "$rec"
    if (( FULL_PATHS == 1 )); then
      echo "${TARGET%/}/${name}"
    else
      echo "$name"
    fi
  done
  for rec in "${sorted_vis_files[@]+"${sorted_vis_files[@]}"}"; do
    IFS='|' read -r name type _ _ excluded _ reason <<< "$rec"
    if (( FULL_PATHS == 1 )); then
      echo "${TARGET%/}/${name}"
    else
      echo "$name"
    fi
  done
  if (( HIDE_EXCLUDED == 0 )); then
    for rec in "${sorted_excluded[@]+"${sorted_excluded[@]}"}"; do
      IFS='|' read -r name type _ _ excluded _ reason <<< "$rec"
      if (( FULL_PATHS == 1 )); then
        echo "${TARGET%/}/${name}"
      else
        echo "$name"
      fi
    done
  fi
}

# -------------------------
# Tree mode
# -------------------------
tree_build_args() {
  # Populates TREE_ARGS array with common tree flags.
  # Flag ordering mirrors v1.0.0's run_tree() exactly.
  TREE_ARGS=(-L "$DEPTH" --dirsfirst --filelimit "$FILELIMIT" -n)
  if [[ -n "$IGNORE_PATTERN" ]]; then
    TREE_ARGS+=(-I "$IGNORE_PATTERN")
  fi
  if (( GITIGNORE == 1 )) && tree_supports_gitignore; then
    TREE_ARGS+=(--gitignore)
  fi
  if (( DIRS_ONLY == 1 )); then
    TREE_ARGS+=(-d)
  fi
  if (( FULL_PATHS == 1 )); then
    TREE_ARGS+=(-f)
  fi
  if (( SIZES == 1 )); then
    TREE_ARGS+=(-s -h)
  fi
}

tree_capture_body_and_counts() {
  TREE_BODY_LINES=()
  TREE_REPORT_LINE=""
  TREE_DIRS=0
  TREE_FILES=0
  TREE_COUNTS_VALID=0

  local -a lines=()
  mapfile -t lines < <(tree "$TARGET" "${TREE_ARGS[@]}" 2>/dev/null || true)

  local total=${#lines[@]}
  if (( total == 0 )); then return; fi

  # Scan backward for the report line.
  # tree's summary always looks like: "12 directories, 47 files"
  # We require BOTH "director" and "file" on the same line, anchored to
  # start-of-line digit, to prevent filename spoofing.
  local i report_idx=-1
  for (( i = total - 1; i >= 0; i-- )); do
    if [[ "${lines[i]}" =~ ^[0-9]+[[:space:]]+director ]] && \
       [[ "${lines[i]}" =~ [0-9]+[[:space:]]+file ]]; then
      report_idx=$i
      break
    fi
  done

  if (( report_idx >= 0 )); then
    TREE_REPORT_LINE="${lines[$report_idx]}"
    TREE_BODY_LINES=("${lines[@]:0:$report_idx}")
    TREE_COUNTS_VALID=1
  else
    # No report line found: treat entire output as body
    TREE_BODY_LINES=("${lines[@]}")
  fi

  if [[ "$TREE_REPORT_LINE" =~ ([0-9]+)[[:space:]]+director ]]; then
    TREE_DIRS="${BASH_REMATCH[1]}"
  fi
  if [[ "$TREE_REPORT_LINE" =~ ([0-9]+)[[:space:]]+file ]]; then
    TREE_FILES="${BASH_REMATCH[1]}"
  fi
}

# Runs tree -J using TREE_ARGS (requires tree_build_args() already called).
# Outputs JSON string to stdout, or "[]" on failure.
tree_native_json() {
  local output
  output=$(tree "$TARGET" -J "${TREE_ARGS[@]}" 2>/dev/null) || output="[]"
  printf "%s" "$output"
}

# Builds JSON array from TREE_BODY_LINES, bounded by $1 = line limit.
# Requires tree_capture_body_and_counts() already called.
tree_lines_json() {
  local line_limit="$1"
  local total=${#TREE_BODY_LINES[@]}
  if (( line_limit > total )); then line_limit=$total; fi
  local result="["
  local li first=1
  for (( li = 0; li < line_limit; li++ )); do
    (( first )) || result+=","
    first=0
    result+="\"$(printf "%s" "${TREE_BODY_LINES[li]}" | json_escape)\""
  done
  result+="]"
  printf "%s" "$result"
}

# Emits the tree JSON object to stdout (no trailing newline).
# Requires tree_build_args() + tree_capture_body_and_counts() already called.
# $1: include_lines (0 or 1). When 1, appends "lines" field.
emit_tree_json_object() {
  local include_lines="${1:-0}"
  local total_lines=${#TREE_BODY_LINES[@]}
  local shown_lines="$total_lines"
  local truncated="false"
  if (( MAX_LINES > 0 )) && (( total_lines > MAX_LINES )); then
    shown_lines="$MAX_LINES"
    truncated="true"
  fi

  local native_json
  native_json="$(tree_native_json)"

  echo -n "{"
  echo -n "\"tool\":\"ftree\","
  echo -n "\"version\":\"$VERSION\","
  echo -n "\"mode\":\"tree\","
  echo -n "\"backend\":\"tree\","
  echo -n "\"path\":\"$(printf "%s" "$ABS_TARGET" | json_escape)\","
  echo -n "\"depth\":$DEPTH,"
  echo -n "\"filelimit\":$FILELIMIT,"
  echo -n "\"ignored\":\"$(printf "%s" "$IGNORE_PATTERN" | json_escape)\","
  echo -n "\"total_dirs\":$TREE_DIRS,"
  echo -n "\"total_files\":$TREE_FILES,"
  echo -n "\"total_lines\":$total_lines,"
  echo -n "\"shown_lines\":$shown_lines,"
  echo -n "\"truncated\":$truncated,"
  echo -n "\"tree_json\":$native_json"
  if (( include_lines == 1 )); then
    echo -n ",\"lines\":$(tree_lines_json "$shown_lines")"
  fi
  echo -n "}"
}

run_tree_pretty() {
  tree_build_args
  tree_capture_body_and_counts

  local total_content=${#TREE_BODY_LINES[@]}
  local shown_lines="$total_content"
  local truncated=0
  if (( MAX_LINES > 0 )) && (( total_content > MAX_LINES )); then
    shown_lines="$MAX_LINES"
    truncated=1
  fi

  if (( QUIET == 0 )); then
    echo "Tree($ABS_TARGET, depth=$DEPTH, filelimit=$FILELIMIT)"
    local count_label
    if (( TREE_COUNTS_VALID == 1 )); then
      count_label="$TREE_DIRS directories, $TREE_FILES files"
    else
      count_label="? directories, ? files"
    fi
    if (( truncated == 1 )); then
      echo "  ⎿ $count_label (showing $shown_lines of $total_content lines, truncated)"
    else
      echo "  ⎿ $count_label (showing $shown_lines of $total_content lines)"
    fi
    echo ""
  fi

  local i
  for (( i = 0; i < shown_lines && i < total_content; i++ )); do
    echo "${TREE_BODY_LINES[i]}"
  done

  if (( truncated == 1 )); then
    local overflow=$(( total_content - shown_lines ))
    echo ""
    echo "     … $overflow more lines not shown"
    printf "     Drill deeper: ftree -L %d %q\n" "$(( DEPTH + 2 ))" "$ABS_TARGET"
  fi
}

run_tree_paths() {
  # Paths mode: exact copy of v1.0.0 paths block, just wrapped in a function.
  # Note: -fi already includes -f, but v1.0.0 also appended -f when --full-paths is set.
  # We keep it for exact parity (duplicate -f is harmless).
  local -a paths_args=(tree "$TARGET" -fi --noreport -n -L "$DEPTH")
  if [[ -n "$IGNORE_PATTERN" ]]; then
    paths_args+=(-I "$IGNORE_PATTERN")
  fi
  if (( DIRS_ONLY == 1 )); then
    paths_args+=(-d)
  fi
  if (( FULL_PATHS == 1 )); then
    paths_args+=(-f)
  fi
  if (( GITIGNORE == 1 )) && tree_supports_gitignore; then
    paths_args+=(--gitignore)
  fi
  "${paths_args[@]}" 2>/dev/null || true
}

run_tree_json() {
  tree_build_args
  tree_capture_body_and_counts
  emit_tree_json_object 0
  echo
}

# -------------------------
# Snapshot mode
# -------------------------
run_snapshot_pretty() {
  echo "Snapshot($ABS_TARGET)"
  echo ""
  echo "== Recon =="
  run_recon
  echo ""
  echo "== Tree =="
  run_tree_pretty
}

run_snapshot_json() {
  # Capture recon JSON (run_recon outputs JSON when OUTPUT=json)
  local recon_json_str
  recon_json_str="$(run_recon)"

  # Tree setup
  tree_build_args
  tree_capture_body_and_counts

  # Emit snapshot JSON envelope with tree object embedded
  echo -n "{"
  echo -n "\"tool\":\"ftree\","
  echo -n "\"version\":\"$VERSION\","
  echo -n "\"mode\":\"snapshot\","
  echo -n "\"path\":\"$(printf "%s" "$ABS_TARGET" | json_escape)\","
  echo -n "\"snapshot\":{"
  echo -n "\"recon\":$recon_json_str,"
  echo -n "\"tree\":"
  emit_tree_json_object $(( NO_LINES == 0 ))
  echo -n "}}"
  echo
}

# -------------------------
# Main
# -------------------------
if (( SNAPSHOT == 1 )); then
  has tree || die 3 "tree is required. Run: ftree --install-hints"
  [[ -d "$TARGET" ]] || die "Not a directory: $TARGET"
  if (( GITIGNORE == 1 )) && ! tree_supports_gitignore; then
    echo "ftree: warning: tree does not support --gitignore (need >= 1.8.0), ignoring flag." >&2
  fi
  case "$OUTPUT" in
    pretty) run_snapshot_pretty ;;
    json)   run_snapshot_json ;;
  esac
elif (( RECON == 1 )); then
  run_recon
else
  has tree || die 3 "tree is required. Run: ftree --install-hints"
  [[ -d "$TARGET" ]] || die "Not a directory: $TARGET"

  # Emit gitignore warning once if needed
  if (( GITIGNORE == 1 )) && ! tree_supports_gitignore; then
    echo "ftree: warning: tree does not support --gitignore (need >= 1.8.0), ignoring flag." >&2
  fi

  case "$OUTPUT" in
    pretty) run_tree_pretty ;;
    paths)  run_tree_paths ;;
    json)   run_tree_json ;;
  esac
fi

exit 0
